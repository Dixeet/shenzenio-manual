import{_ as i,C as r,o as c,c as d,H as n,w as a,k as e,a as t}from"./chunks/framework.9e21ba36.js";const u="/shenzenio-manual/assets/23.eafedb42.webp",m="/shenzenio-manual/assets/24.509140f4.webp",S=JSON.parse('{"title":"200P-14 RANDOM-ONLY MEMORY","description":"","frontmatter":{},"headers":[],"relativePath":"parts/200p-14.md","filePath":"parts/200p-14.md"}'),p={name:"parts/200p-14.md"},h=e("hr",null,null,-1),_=e("h1",{id:"_200p-14-random-only-memory",tabindex:"-1"},[t("200P-14 "),e("br"),t("RANDOM-ONLY MEMORY "),e("a",{class:"header-anchor",href:"#_200p-14-random-only-memory","aria-label":'Permalink to "200P-14 <br>RANDOM-ONLY MEMORY"'},"​")],-1),f=e("hr",null,null,-1),g=e("h2",{id:"general-description",tabindex:"-1"},[t("General description "),e("a",{class:"header-anchor",href:"#general-description","aria-label":'Permalink to "General description"'},"​")],-1),y=e("p",null,[e("code",null,"200P-14"),t(" read-only memory by Pingda Co. Ltd. offers embedded system engineers the ability to easily access up to fourteen factory-programmed memory cells for a wide range of diverse applications. With its convenient auto-increment feature, you won’t have to waste precious registers keeping track of memory addresses.")],-1),b=e("h2",{id:"features",tabindex:"-1"},[t("Features "),e("a",{class:"header-anchor",href:"#features","aria-label":'Permalink to "Features"'},"​")],-1),k=e("ul",null,[e("li",null,"(14) random-access memory cells"),e("li",null,"(2) independent, auto-incrementing memory pointers")],-1),v=e("h2",{id:"usage",tabindex:"-1"},[t("Usage "),e("a",{class:"header-anchor",href:"#usage","aria-label":'Permalink to "Usage"'},"​")],-1),x=e("ul",null,[e("li",null,"All memory cell values are set in advance by the design engineer."),e("li",null,[t("All memory pointers initialize to point at the first memory cell ("),e("code",null,"address 0"),t(").")]),e("li",null,[t("Memory pointers can be read over XBus with the "),e("code",null,"a0"),t(" and "),e("code",null,"a1"),t(" address pins.")]),e("li",null,[t("Memory values referenced by pointers can be read over XBus with the "),e("code",null,"d0"),t(" and "),e("code",null,"d1"),t(" data pins.")]),e("li",null,"After reading from a data pin, the corresponding memory pointer will automatically increment to the next memory location.")],-1),P=e("h2",{id:"example-circuit-data-packet-reverser",tabindex:"-1"},[t("Example Circuit: Data Packet Reverser "),e("a",{class:"header-anchor",href:"#example-circuit-data-packet-reverser","aria-label":'Permalink to "Example Circuit: Data Packet Reverser"'},"​")],-1),w=e("p",null,[t("The following circuit sends a data packet with a predetermined set of values to "),e("code",null,"output"),t(" every time unit that "),e("code",null,"trigger"),t(" is high.")],-1),C=e("img",{src:u,alt:"Example Circuit: Data Packet Reverser"},null,-1),M=e("br",null,null,-1),N=e("img",{src:m,alt:"Example Circuit: Data Packet Reverser Signal"},null,-1);function O(R,D,E,B,A,Y){const l=r("WideSubtitleBlock"),s=r("TwoCols"),o=r("ImgContainer");return c(),d("div",null,[h,_,f,n(s,null,{left:a(()=>[n(l,null,{default:a(()=>[g]),_:1}),y,n(l,null,{default:a(()=>[b]),_:1}),k]),right:a(()=>[n(l,null,{default:a(()=>[v]),_:1}),x]),_:1}),n(l,null,{default:a(()=>[P]),_:1}),w,n(o,null,{default:a(()=>[C]),_:1}),M,n(o,null,{default:a(()=>[N]),_:1})])}const T=i(p,[["render",O]]);export{S as __pageData,T as default};
