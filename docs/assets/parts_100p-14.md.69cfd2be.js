import{_ as i,C as r,o as c,c as d,H as n,w as a,k as e,a as t}from"./chunks/framework.9e21ba36.js";const u="/shenzenio-manual/assets/21.0961ab53.webp",m="/shenzenio-manual/assets/22.c50f0bec.webp",T=JSON.parse('{"title":"100P-14 RANDOM-ACCESS MEMORY","description":"","frontmatter":{},"headers":[],"relativePath":"parts/100p-14.md","filePath":"parts/100p-14.md"}'),p={name:"parts/100p-14.md"},_=e("hr",null,null,-1),h=e("h1",{id:"_100p-14-random-access-memory",tabindex:"-1"},[t("100P-14 "),e("br"),t("RANDOM-ACCESS MEMORY "),e("a",{class:"header-anchor",href:"#_100p-14-random-access-memory","aria-label":'Permalink to "100P-14 <br>RANDOM-ACCESS MEMORY"'},"​")],-1),f=e("hr",null,null,-1),g=e("h2",{id:"general-description",tabindex:"-1"},[t("General description "),e("a",{class:"header-anchor",href:"#general-description","aria-label":'Permalink to "General description"'},"​")],-1),b=e("p",null,[e("code",null,"100P-14"),t("random-access memory by Pingda Co. Ltd. offers embedded system engineers additional storage for today’s increasingly data-driven world with a whopping fourteen memory cells. With its convenient auto-increment feature, you won’t have to waste precious registers keeping track of memory addresses.")],-1),y=e("h2",{id:"features",tabindex:"-1"},[t("Features "),e("a",{class:"header-anchor",href:"#features","aria-label":'Permalink to "Features"'},"​")],-1),k=e("ul",null,[e("li",null,"(14) random-access memory cells"),e("li",null,"(2) independent, auto-incrementing memory pointers")],-1),v=e("h2",{id:"usage",tabindex:"-1"},[t("Usage "),e("a",{class:"header-anchor",href:"#usage","aria-label":'Permalink to "Usage"'},"​")],-1),w=e("ul",null,[e("li",null,"All memory cells initialize to a value of 0."),e("li",null,[t("All memory pointers initialize to point at the first memory cell ("),e("code",null,"address 0"),t(").")]),e("li",null,[t("Memory pointers can be read and written over XBus with the "),e("code",null,"a0"),t(" and "),e("code",null,"a1"),t(" address pins.")]),e("li",null,[t("Memory values referenced by pointers can be read and written over XBus with the "),e("code",null,"d0"),t(" and "),e("code",null,"d1"),t(" data pins.")]),e("li",null,"After reading from or writing to a data pin, the corresponding memory pointer will automatically increment to the next memory location.")],-1),x=e("h2",{id:"example-circuit-data-packet-reverser",tabindex:"-1"},[t("Example Circuit: Data Packet Reverser "),e("a",{class:"header-anchor",href:"#example-circuit-data-packet-reverser","aria-label":'Permalink to "Example Circuit: Data Packet Reverser"'},"​")],-1),C=e("p",null,[t("The following example circuit reads in 3-value packets from "),e("code",null,"input"),t(" and writes them back out to "),e("code",null,"output"),t(" in reverse order, using a "),e("code",null,"100P-14"),t(" to temporarily store the values.")],-1),P=e("img",{src:u,alt:"Example Circuit: Data Packet Reverser"},null,-1),E=e("br",null,null,-1),M=e("img",{src:m,alt:"Example Circuit: Data Packet Reverser Signal"},null,-1);function R(S,A,D,B,N,O){const l=r("WideSubtitleBlock"),s=r("TwoCols"),o=r("ImgContainer");return c(),d("div",null,[_,h,f,n(s,null,{left:a(()=>[n(l,null,{default:a(()=>[g]),_:1}),b,n(l,null,{default:a(()=>[y]),_:1}),k]),right:a(()=>[n(l,null,{default:a(()=>[v]),_:1}),w]),_:1}),n(l,null,{default:a(()=>[x]),_:1}),C,n(o,null,{default:a(()=>[P]),_:1}),E,n(o,null,{default:a(()=>[M]),_:1})])}const $=i(p,[["render",R]]);export{T as __pageData,$ as default};
